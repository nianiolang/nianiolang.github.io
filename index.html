<!DOCTYPE html>
<html>

  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="description" content="NianioLang : Procedural programming language without pointers">

    <link rel="stylesheet" type="text/css" media="screen" href="stylesheets/stylesheet.css">

    <title>NianioLang</title>
  </head>

  <body>

    <!-- HEADER -->
    <div id="header_wrap" class="outer">
        <header class="inner">
          <a id="forkme_banner" href="https://github.com/nianiolang">View on GitHub</a>

          <h1 id="project_title">NianioLang</h1>
          <h2 id="project_tagline">Procedural programming language without pointers</h2>

        </header>
    </div>

    <!-- MAIN CONTENT -->
    <div id="main_content_wrap" class="outer">
      <section id="main_content" class="inner">
        <h3>
<a id="research-area" class="anchor" href="#research-area" aria-hidden="true"><span class="octicon octicon-link"></span></a>Research Area</h3>

<p>We have identified the following areas where we seek improvement in software development:</p>

<ul>
<li>Development of concurrent code</li>
<li>Development of code with asynchronous communication from different sources</li>
<li>Software quality management in large code bases</li>
</ul>

<h3>
<a id="nianio-lang-design-principles" class="anchor" href="#nianio-lang-design-principles" aria-hidden="true"><span class="octicon octicon-link"></span></a>Nianio Lang Design Principles</h3>

<p>Our answer to these challenges is Nianio Lang language. Its design principles consists of:</p>

<ul>
<li>Architecture oriented language

<ul>
<li>We do not focus on micro-convenience for programmers. We always value higher better code organization at the architecture level to a few less lines at the function level.</li>
</ul>
</li>
<li>Semantics centric language

<ul>
<li>We have removed low-level features like pointers and modifiable objects, that are the root cause of undefined behavior of programs, in particular concurrent ones. We have added features that allow high-level of optimizations that preserve simple semantics instead.</li>
<li>Advanced features of the language like static typing or optimizations do not change semantics of the base code. It means that very simple compilation process of stripped-down language produces code of the same semantics that advanced compilation that uses static typing and other hints provided by the programmer.</li>
</ul>
</li>
<li>Language characterics

<ul>
<li>Procedural imperative language</li>
<li>Strict value semantics for argument passing</li>
<li>No global variables</li>
<li>Generation of embeddable code. No need for VM.</li>
<li>Small compiler or interpreter size</li>
<li>Automatic memory management</li>
<li>No garbage collection</li>
</ul>
</li>
<li>No overloading of functions and operators

<ul>
<li>All function must be explicitly called with package name. This provides more readability and simplifies compilation process.</li>
</ul>
</li>
<li>Strictly Optional Typing

<ul>
<li>Types are optional and providing type information do not change semantics of the program, but ensures its properties and allows for optimization. In particular, every program may be stripped off all type information and executed by simple interpreter with semantics kept intact.</li>
</ul>
</li>
<li>Compile time function execution and value expansion.

<ul>
<li>Since we depend on value passing semantics, all functions that do not have extenal dependencies may be executed by compiler and their result may be inlined. This allows for deep inlining and optimizations.</li>
</ul>
</li>
<li>Language for complex logic implementation (as opposed to small functions and up-to-cycle optimizations)</li>
<li>Execution speed comparable to C.

<ul>
<li>We aim to achieve 3 times low-level performance degradation as compared to simple C programs, while keeping all safety and semantics guarantees. Larger code base may benefit from in-depth optimizations. Critical functions have an option to call C code directly.</li>
</ul>
</li>
</ul>

<h3>
<a id="current-status" class="anchor" href="#current-status" aria-hidden="true"><span class="octicon octicon-link"></span></a>Current status</h3>

<p>Nianio Lang is actively used in development of instadb.com platform.</p>

<ul>
<li>Already implemented:

<ul>
<li>Compiler</li>
<li>Static type checker</li>
<li>Module dependency verifier</li>
<li>Around 50KLOC of Nianio Lang in production use serve distributed infrastructure for instadb.com platform and its customers</li>
<li>Online JavaScript interpreter and debugger</li>
<li>C compiler</li>
</ul>
</li>
<li>Work in progress

<ul>
<li>Highly optimizing C compiler</li>
<li>JavaScript compiler</li>
</ul>
</li>
</ul>

<h3>
<a id="potential-applications" class="anchor" href="#potential-applications" aria-hidden="true"><span class="octicon octicon-link"></span></a>Potential Applications</h3>

<p>We see potential in the following areas:</p>

<ul>
<li>Embedded software</li>
<li>Distributed software</li>
<li>Error-proof software, in particular formal verifications</li>
</ul>

<h3>
<a id="references" class="anchor" href="#references" aria-hidden="true"><span class="octicon octicon-link"></span></a>References</h3>

<p>Andrzej Gąsienica Samek, Tomasz Stachowicz, Jacek Chrząszcz and Aleksy Schubert "KOTEK: Clustering of The Enterprise Code", in "Software Engineering: Evolution and Emerging Technologies", Krzysztof Zieliński and Tomasz Szmuc, editors, volume 130, IOS Press, 2005, pp. 412-417 © IOS Press </p>

<p>Jacek Chrząszcz, Tomasz Stachowicz, Andrzej Gąsienica-Samek, and Aleksy Schubert. "Minik: A tool for maintaining proper Java code structure", in Proceedings of SET'2006, IFIP, Springer, 2006, pp. 361-372.© Springer-Verlag </p>
      </section>
    </div>

    <!-- FOOTER  -->
    <div id="footer_wrap" class="outer">
      <footer class="inner">
        <p>Published with <a href="https://pages.github.com">GitHub Pages</a></p>
      </footer>
    </div>

    

  </body>
</html>
